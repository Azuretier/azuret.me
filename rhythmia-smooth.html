<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RHYTHMIA</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; }
        
        html, body { 
            height: 100%; 
            overflow: hidden; 
            touch-action: manipulation;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        body {
            background: #0a0a12;
            transition: background 0.5s;
        }

        /* ‰∏ñÁïå„ÉÜ„Éº„Éû */
        .w0 { --c1: #FF6B9D; --c2: #C44569; --bg: #1a1025; }
        .w1 { --c1: #4ECDC4; --c2: #1A535C; --bg: #051620; }
        .w2 { --c1: #FFE66D; --c2: #F7B731; --bg: #1a1505; }
        .w3 { --c1: #FF6B6B; --c2: #C0392B; --bg: #1a0a0a; }
        .w4 { --c1: #A29BFE; --c2: #6C5CE7; --bg: #0a0a1a; }

        body { background: var(--bg); }

        #game {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            gap: 10px;
        }

        /* „Çπ„Ç≥„Ç¢Ë°®Á§∫ */
        #score-display {
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 900;
            color: white;
            text-shadow: 0 0 30px var(--c1);
            transition: transform 0.1s;
        }
        #score-display.pop { transform: scale(1.2); }

        /* „Ç≥„É≥„Éú */
        #combo {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            font-weight: 700;
            color: var(--c1);
            opacity: 0;
            transform: scale(0);
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #combo.show { opacity: 1; transform: scale(1); }
        #combo.big { transform: scale(1.5); color: #FFD700; }

        /* „Ç≤„Éº„É†„Ç®„É™„Ç¢ */
        #game-area {
            position: relative;
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        /* „Éú„Éº„Éâ */
        #board-wrap {
            position: relative;
            border: 3px solid var(--c1);
            border-radius: 8px;
            background: rgba(0,0,0,0.5);
            box-shadow: 0 0 30px var(--c1), inset 0 0 30px rgba(0,0,0,0.5);
            transition: box-shadow 0.1s, transform 0.1s;
            overflow: hidden;
        }
        #board-wrap.beat { 
            box-shadow: 0 0 50px var(--c1), 0 0 80px var(--c1), inset 0 0 30px rgba(0,0,0,0.5);
            transform: scale(1.02);
        }
        #board-wrap.shake {
            animation: shake 0.2s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        #board {
            display: grid;
            gap: 1px;
            position: relative;
        }

        .cell {
            width: clamp(16px, 4vw, 28px);
            height: clamp(16px, 4vw, 28px);
            background: rgba(255,255,255,0.03);
            border-radius: 2px;
            transition: all 0.1s;
        }
        .cell.filled {
            box-shadow: 0 0 10px currentColor, inset 0 0 8px rgba(255,255,255,0.3);
        }
        .cell.ghost {
            opacity: 0.3;
        }
        .cell.clearing {
            animation: clear 0.3s ease-out forwards;
        }
        @keyframes clear {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); background: white; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* ËêΩ‰∏ã‰∏≠„ÅÆ„Éî„Éº„ÇπÔºà„Çπ„É†„Éº„Ç∫ÁßªÂãïÔºâ */
        #active-piece {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: transform 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }
        #active-piece.dropping {
            transition: transform 0.02s linear;
        }
        .piece-cell {
            position: absolute;
            border-radius: 2px;
            box-shadow: 0 0 10px currentColor, inset 0 0 8px rgba(255,255,255,0.3);
        }

        /* NEXT */
        #next-wrap {
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px;
        }
        #next-label {
            color: rgba(255,255,255,0.5);
            font-size: 0.7rem;
            text-align: center;
            margin-bottom: 5px;
        }
        #next {
            display: grid;
            gap: 1px;
        }
        .next-cell {
            width: clamp(12px, 3vw, 20px);
            height: clamp(12px, 3vw, 20px);
            border-radius: 2px;
        }

        /* „Éì„Éº„Éà„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº */
        #beat-bar {
            width: min(300px, 80vw);
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        #beat-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--c2), var(--c1));
            border-radius: 10px;
            transition: width 0.05s linear;
            box-shadow: 0 0 20px var(--c1);
        }
        #beat-target {
            position: absolute;
            right: 10%;
            top: 0;
            bottom: 0;
            width: 15%;
            background: rgba(255,215,0,0.3);
            border: 2px solid #FFD700;
            border-radius: 8px;
        }

        /* Âà§ÂÆöË°®Á§∫ */
        #judgment {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2rem, 10vw, 5rem);
            font-weight: 900;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }
        #judgment.show {
            animation: judgePop 0.5s ease-out forwards;
        }
        @keyframes judgePop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
            100% { opacity: 0; transform: translate(-50%, -60%) scale(1); }
        }

        /* „Ç≥„É≥„Éà„É≠„Éº„É´ */
        #controls {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            width: min(350px, 90vw);
        }
        .ctrl-btn {
            aspect-ratio: 1;
            background: linear-gradient(135deg, var(--c1), var(--c2));
            border: none;
            border-radius: 12px;
            color: white;
            font-size: clamp(1.2rem, 4vw, 2rem);
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        .ctrl-btn:active {
            transform: scale(0.9);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* „Çø„Ç§„Éà„É´ÁîªÈù¢ */
        #title-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            z-index: 200;
            gap: 30px;
        }
        #title-screen h1 {
            font-size: clamp(3rem, 12vw, 6rem);
            font-weight: 900;
            color: white;
            text-shadow: 0 0 30px var(--c1), 0 0 60px var(--c1);
        }
        #title-screen p {
            color: rgba(255,255,255,0.7);
            font-size: 1.2rem;
        }
        #start-btn {
            padding: 20px 60px;
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--c1), var(--c2));
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            box-shadow: 0 0 30px var(--c1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px var(--c1);
        }

        /* „ÉØ„Éº„É´„ÉâË°®Á§∫ */
        #world-display {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* ÊïµHP */
        #enemy-bar {
            width: min(250px, 70vw);
            height: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            overflow: hidden;
        }
        #enemy-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF4444, #FF8888);
            transition: width 0.3s;
            box-shadow: 0 0 10px #FF4444;
        }
        #enemy-label {
            color: rgba(255,255,255,0.6);
            font-size: 0.8rem;
            text-align: center;
        }

        /* „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº */
        #gameover {
            position: fixed;
            inset: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.9);
            z-index: 200;
            gap: 20px;
        }
        #gameover.show { display: flex; }
        #gameover h2 {
            font-size: 3rem;
            color: var(--c1);
            text-shadow: 0 0 30px var(--c1);
        }
        #final-score {
            font-size: 2rem;
            color: white;
        }

        /* „Éë„Éº„ÉÜ„Ç£„ÇØ„É´ */
        .particle {
            position: fixed;
            pointer-events: none;
            border-radius: 50%;
            z-index: 150;
        }
    </style>
</head>
<body class="w0">
    <!-- „Çø„Ç§„Éà„É´ -->
    <div id="title-screen">
        <h1>RHYTHMIA</h1>
        <p>„É™„Ç∫„É†„Å´‰πó„Å£„Å¶„Éñ„É≠„ÉÉ„ÇØ„ÇíÁ©ç„ÇÅÔºÅ</p>
        <button id="start-btn">‚ñ∂ START</button>
    </div>

    <!-- „Ç≤„Éº„É† -->
    <div id="game" style="display:none;">
        <div id="world-display">üéÄ „É°„É≠„Éá„Ç£„Ç¢</div>
        
        <div id="score-display">0</div>
        <div id="combo">10 COMBO!</div>
        
        <div id="enemy-label">üëª „Éé„Ç§„Ç∫„É™„É≥„Ç∞</div>
        <div id="enemy-bar"><div id="enemy-fill" style="width:100%"></div></div>
        
        <div id="game-area">
            <div id="board-wrap">
                <div id="board"></div>
                <div id="active-piece"></div>
            </div>
            <div id="next-wrap">
                <div id="next-label">NEXT</div>
                <div id="next"></div>
            </div>
        </div>
        
        <div id="beat-bar">
            <div id="beat-target"></div>
            <div id="beat-fill" style="width:0%"></div>
        </div>
        
        <div id="controls">
            <button class="ctrl-btn" data-action="rotate">‚Üª</button>
            <button class="ctrl-btn" data-action="left">‚Üê</button>
            <button class="ctrl-btn" data-action="down">‚Üì</button>
            <button class="ctrl-btn" data-action="right">‚Üí</button>
            <button class="ctrl-btn" data-action="drop">‚¨á</button>
        </div>
    </div>

    <!-- Âà§ÂÆö -->
    <div id="judgment"></div>

    <!-- „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº -->
    <div id="gameover">
        <h2>GAME OVER</h2>
        <div id="final-score">0</div>
        <button id="restart-btn" style="padding:15px 40px;font-size:1.2rem;background:linear-gradient(135deg,var(--c1),var(--c2));border:none;border-radius:30px;color:white;cursor:pointer;">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
    </div>

    <script>
        // ===== Ë®≠ÂÆö =====
        const W = 10, H = 18;
        const WORLDS = [
            { name: 'üéÄ „É°„É≠„Éá„Ç£„Ç¢', bpm: 100, colors: ['#FF6B9D','#FF8FAB','#FFB6C1','#C44569','#E8668B','#D4587D','#B84A6F'] },
            { name: 'üåä „Éè„Éº„É¢„Éã„Ç¢', bpm: 110, colors: ['#4ECDC4','#45B7AA','#3DA69B','#35958C','#2D847D','#26736E','#1A535C'] },
            { name: '‚òÄÔ∏è „ÇØ„É¨„Ç∑„Çß„É≥„ÉÄ', bpm: 120, colors: ['#FFE66D','#FFD93D','#F7B731','#ECA700','#D19600','#B68600','#9B7600'] },
            { name: 'üî• „Éï„Ç©„É´„ÉÜ„Ç£„ÉÉ„Ç∑„É¢', bpm: 140, colors: ['#FF6B6B','#FF5252','#FF3838','#FF1F1F','#E61717','#CC0F0F','#B30707'] },
            { name: '‚ú® ÈùôÂØÇ„ÅÆÈñì', bpm: 160, colors: ['#A29BFE','#9B8EFD','#9381FC','#8B74FB','#8367FA','#7B5AF9','#6C5CE7'] }
        ];
        
        const SHAPES = [
            [[1,1,1,1]],
            [[1,1],[1,1]],
            [[0,1,0],[1,1,1]],
            [[0,1,1],[1,1,0]],
            [[1,1,0],[0,1,1]],
            [[1,0,0],[1,1,1]],
            [[0,0,1],[1,1,1]]
        ];

        // ===== Áä∂ÊÖã =====
        let board, piece, piecePos, nextPiece, score, combo, level, lines;
        let worldIdx, enemyHP, gameOver, paused;
        let beatPhase, lastBeat, audioCtx;
        let dropTimer, beatTimer;
        let cellSize = 20; // „Çª„É´„Çµ„Ç§„Ç∫Ôºà„Éî„ÇØ„Çª„É´Ôºâ
        let gapSize = 1;   // „ÇÆ„É£„ÉÉ„Éó„Çµ„Ç§„Ç∫

        // ===== DOM =====
        const $ = id => document.getElementById(id);
        const boardEl = $('board');
        const nextEl = $('next');
        const scoreEl = $('score-display');
        const comboEl = $('combo');
        const judgmentEl = $('judgment');
        const beatFill = $('beat-fill');
        const enemyFill = $('enemy-fill');
        const enemyLabel = $('enemy-label');
        const worldDisplay = $('world-display');
        const boardWrap = $('board-wrap');
        const activePieceEl = $('active-piece');

        // ===== „Çµ„Ç¶„É≥„Éâ =====
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playTone(freq, dur = 0.1, type = 'sine') {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + dur);
        }

        function playDrum() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function playLineClear(count) {
            const freqs = [523, 659, 784, 1047];
            freqs.slice(0, count).forEach((f, i) => setTimeout(() => playTone(f, 0.15, 'triangle'), i * 60));
        }

        // ===== „Éë„Éº„ÉÜ„Ç£„ÇØ„É´ =====
        function spawnParticles(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                const size = Math.random() * 10 + 5;
                const angle = (Math.PI * 2 / count) * i;
                const dist = Math.random() * 80 + 40;
                p.style.cssText = `
                    left: ${x}px; top: ${y}px;
                    width: ${size}px; height: ${size}px;
                    background: ${color};
                    box-shadow: 0 0 10px ${color};
                    transition: all 0.5s ease-out;
                `;
                document.body.appendChild(p);
                requestAnimationFrame(() => {
                    p.style.transform = `translate(${Math.cos(angle) * dist}px, ${Math.sin(angle) * dist}px) scale(0)`;
                    p.style.opacity = '0';
                });
                setTimeout(() => p.remove(), 500);
            }
        }

        // ===== „Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ =====
        function createBoard() {
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${W}, 1fr)`;
            for (let i = 0; i < W * H; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                boardEl.appendChild(cell);
            }
            
            // „Çª„É´„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
            requestAnimationFrame(() => {
                const firstCell = boardEl.querySelector('.cell');
                if (firstCell) {
                    const rect = firstCell.getBoundingClientRect();
                    cellSize = rect.width;
                }
            });
        }

        function randomPiece() {
            const world = WORLDS[worldIdx];
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const color = world.colors[Math.floor(Math.random() * world.colors.length)];
            return { shape, color };
        }

        // Âõ∫ÂÆö„Åï„Çå„Åü„Éñ„É≠„ÉÉ„ÇØ„Å®„Ç¥„Éº„Çπ„Éà„Å†„Åë„ÇíÊèèÁîª
        function drawBoard() {
            const cells = boardEl.children;
            const display = board.map(r => [...r]);
            
            // „Ç¥„Éº„Çπ„Éà‰ΩçÁΩÆ„ÇíË®àÁÆó
            if (piece) {
                let gy = piecePos.y;
                while (!collision(piece, piecePos.x, gy + 1)) gy++;
                piece.shape.forEach((row, py) => {
                    row.forEach((val, px) => {
                        if (val) {
                            const by = gy + py, bx = piecePos.x + px;
                            if (by >= 0 && by < H && bx >= 0 && bx < W && !display[by][bx]) {
                                display[by][bx] = { color: piece.color, ghost: true };
                            }
                        }
                    });
                });
            }
            
            // „Ç∞„É™„ÉÉ„Éâ„Å´Âõ∫ÂÆö„Éñ„É≠„ÉÉ„ÇØ„Å®„Ç¥„Éº„Çπ„Éà„ÇíÊèèÁîª
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const cell = cells[y * W + x];
                    const val = display[y][x];
                    if (val) {
                        cell.className = 'cell filled' + (val.ghost ? ' ghost' : '');
                        cell.style.backgroundColor = val.color;
                        cell.style.color = val.color;
                    } else {
                        cell.className = 'cell';
                        cell.style.backgroundColor = '';
                        cell.style.color = '';
                    }
                }
            }
        }

        // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Éî„Éº„Çπ„Çí„Çπ„É†„Éº„Ç∫„Å´ÊèèÁîª
        function drawActivePiece(instant = false) {
            if (!piece) {
                activePieceEl.innerHTML = '';
                return;
            }

            // „Çª„É´„Çµ„Ç§„Ç∫„ÇíÂÜçË®àÁÆó
            const firstCell = boardEl.querySelector('.cell');
            if (firstCell) {
                const rect = firstCell.getBoundingClientRect();
                cellSize = rect.width;
            }

            const unit = cellSize + gapSize;
            
            // „Éî„Éº„Çπ„ÅÆ„Çª„É´„ÇíÁîüÊàêÔºà‰∏ÄÂ∫¶„Å†„ÅëÔºâ
            if (activePieceEl.children.length === 0 || activePieceEl.dataset.color !== piece.color) {
                activePieceEl.innerHTML = '';
                piece.shape.forEach((row, py) => {
                    row.forEach((val, px) => {
                        if (val) {
                            const cell = document.createElement('div');
                            cell.className = 'piece-cell';
                            cell.style.width = cellSize + 'px';
                            cell.style.height = cellSize + 'px';
                            cell.style.backgroundColor = piece.color;
                            cell.style.color = piece.color;
                            cell.style.left = (px * unit) + 'px';
                            cell.style.top = (py * unit) + 'px';
                            activePieceEl.appendChild(cell);
                        }
                    });
                });
                activePieceEl.dataset.color = piece.color;
            }

            // ‰ΩçÁΩÆ„Çí„Çπ„É†„Éº„Ç∫„Å´Êõ¥Êñ∞
            if (instant) {
                activePieceEl.classList.add('dropping');
            } else {
                activePieceEl.classList.remove('dropping');
            }
            
            const x = piecePos.x * unit;
            const y = piecePos.y * unit;
            activePieceEl.style.transform = `translate(${x}px, ${y}px)`;
        }

        function rebuildActivePiece() {
            activePieceEl.innerHTML = '';
            activePieceEl.dataset.color = '';
            drawActivePiece(true);
        }

        function drawNext() {
            if (!nextPiece) return;
            const shape = nextPiece.shape;
            nextEl.innerHTML = '';
            nextEl.style.gridTemplateColumns = `repeat(${shape[0].length}, 1fr)`;
            shape.forEach(row => {
                row.forEach(val => {
                    const cell = document.createElement('div');
                    cell.className = 'next-cell';
                    if (val) {
                        cell.style.backgroundColor = nextPiece.color;
                        cell.style.boxShadow = `0 0 8px ${nextPiece.color}`;
                    }
                    nextEl.appendChild(cell);
                });
            });
        }

        function collision(p, x, y) {
            return p.shape.some((row, py) =>
                row.some((val, px) => {
                    if (!val) return false;
                    const nx = x + px, ny = y + py;
                    return nx < 0 || nx >= W || ny >= H || (ny >= 0 && board[ny][nx]);
                })
            );
        }

        function rotate(p) {
            return {
                ...p,
                shape: p.shape[0].map((_, i) => p.shape.map(row => row[i]).reverse())
            };
        }

        function lock() {
            // „Éì„Éº„ÉàÂà§ÂÆö
            const onBeat = beatPhase > 0.75 || beatPhase < 0.15;
            let mult = 1;
            
            if (onBeat) {
                mult = 2;
                combo++;
                showJudgment('PERFECT!', '#FFD700');
                playTone(1047, 0.2, 'triangle');
                const rect = boardWrap.getBoundingClientRect();
                spawnParticles(rect.left + rect.width/2, rect.top + rect.height/2, '#FFD700', 12);
            } else {
                combo = 0;
            }
            
            updateCombo();
            
            // „Éú„Éº„Éâ„Å´Âõ∫ÂÆö
            piece.shape.forEach((row, py) => {
                row.forEach((val, px) => {
                    if (val) {
                        const by = piecePos.y + py, bx = piecePos.x + px;
                        if (by >= 0 && by < H) {
                            board[by][bx] = { color: piece.color };
                        }
                    }
                });
            });
            
            // „É©„Ç§„É≥Ê∂àÂéª
            let cleared = 0;
            const newBoard = [];
            const clearingRows = [];
            
            board.forEach((row, y) => {
                if (row.every(c => c !== null)) {
                    cleared++;
                    clearingRows.push(y);
                } else {
                    newBoard.push(row);
                }
            });
            
            // Ê∂àÂéª„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
            if (cleared > 0) {
                const cells = boardEl.children;
                clearingRows.forEach(y => {
                    for (let x = 0; x < W; x++) {
                        cells[y * W + x].classList.add('clearing');
                    }
                });
                
                setTimeout(() => {
                    while (newBoard.length < H) newBoard.unshift(Array(W).fill(null));
                    board = newBoard;
                    
                    const pts = [0, 100, 300, 500, 800][cleared] * (level + 1) * mult * Math.max(1, combo);
                    score += pts;
                    lines += cleared;
                    
                    // Êïµ„ÉÄ„É°„Éº„Ç∏
                    enemyHP = Math.max(0, enemyHP - cleared * 8 * mult);
                    enemyFill.style.width = enemyHP + '%';
                    
                    if (enemyHP <= 0) {
                        nextWorld();
                    }
                    
                    level = Math.floor(lines / 10);
                    updateScore();
                    playLineClear(cleared);
                    boardWrap.classList.add('shake');
                    setTimeout(() => boardWrap.classList.remove('shake'), 200);
                    
                    drawBoard();
                }, 300);
            }
            
            // Ê¨°„ÅÆ„Éî„Éº„Çπ
            piece = nextPiece;
            nextPiece = randomPiece();
            piecePos = { x: Math.floor(W/2) - 1, y: 0 };
            rebuildActivePiece();
            drawNext();
            drawBoard();
            
            if (collision(piece, piecePos.x, piecePos.y)) {
                endGame();
            }
        }

        function move(dx, dy) {
            if (gameOver || paused || !piece) return;
            if (!collision(piece, piecePos.x + dx, piecePos.y + dy)) {
                piecePos.x += dx;
                piecePos.y += dy;
                if (dx !== 0) playTone(392, 0.05, 'square');
                drawActivePiece();
                drawBoard(); // „Ç¥„Éº„Çπ„ÉàÊõ¥Êñ∞
            } else if (dy > 0) {
                lock();
            }
        }

        function rotatePiece() {
            if (gameOver || paused || !piece) return;
            const rotated = rotate(piece);
            if (!collision(rotated, piecePos.x, piecePos.y)) {
                piece = rotated;
                playTone(523, 0.08);
                rebuildActivePiece();
                drawBoard();
            }
        }

        function hardDrop() {
            if (gameOver || paused || !piece) return;
            
            // Âç≥Â∫ß„Å´„Éâ„É≠„ÉÉ„Éó
            activePieceEl.classList.add('dropping');
            while (!collision(piece, piecePos.x, piecePos.y + 1)) {
                piecePos.y++;
            }
            playTone(196, 0.1, 'sawtooth');
            drawActivePiece(true);
            drawBoard();
            setTimeout(lock, 30);
        }

        function showJudgment(text, color) {
            judgmentEl.textContent = text;
            judgmentEl.style.color = color;
            judgmentEl.style.textShadow = `0 0 30px ${color}`;
            judgmentEl.className = '';
            void judgmentEl.offsetWidth;
            judgmentEl.classList.add('show');
        }

        function updateScore() {
            scoreEl.textContent = score.toLocaleString();
            scoreEl.classList.add('pop');
            setTimeout(() => scoreEl.classList.remove('pop'), 100);
        }

        function updateCombo() {
            if (combo >= 2) {
                comboEl.textContent = combo + ' COMBO!';
                comboEl.classList.add('show');
                if (combo >= 5) comboEl.classList.add('big');
                else comboEl.classList.remove('big');
            } else {
                comboEl.classList.remove('show', 'big');
            }
        }

        function nextWorld() {
            worldIdx++;
            if (worldIdx >= WORLDS.length) {
                // „Ç≤„Éº„É†„ÇØ„É™„Ç¢
                showJudgment('üéâ CLEAR!', '#FFD700');
                setTimeout(() => {
                    worldIdx = 0;
                    enemyHP = 100;
                    setWorld();
                }, 2000);
            } else {
                showJudgment('WORLD CLEAR!', '#00FF00');
                enemyHP = 100;
                setWorld();
            }
        }

        function setWorld() {
            const world = WORLDS[worldIdx];
            document.body.className = 'w' + worldIdx;
            worldDisplay.textContent = world.name;
            enemyFill.style.width = enemyHP + '%';
            
            // BPM„Å´Âêà„Çè„Åõ„Å¶„Éì„Éº„ÉàÈñìÈöîË™øÊï¥
            clearInterval(beatTimer);
            const interval = 60000 / world.bpm;
            lastBeat = Date.now();
            beatTimer = setInterval(() => {
                lastBeat = Date.now();
                boardWrap.classList.add('beat');
                playDrum();
                setTimeout(() => boardWrap.classList.remove('beat'), 100);
            }, interval);
        }

        function startGame() {
            board = Array(H).fill().map(() => Array(W).fill(null));
            score = 0;
            combo = 0;
            level = 0;
            lines = 0;
            worldIdx = 0;
            enemyHP = 100;
            gameOver = false;
            paused = false;
            
            piece = randomPiece();
            nextPiece = randomPiece();
            piecePos = { x: Math.floor(W/2) - 1, y: 0 };
            
            createBoard();
            
            // „Çª„É´„Çµ„Ç§„Ç∫ÂèñÂæóÂæå„Å´ÊèèÁîª
            requestAnimationFrame(() => {
                const firstCell = boardEl.querySelector('.cell');
                if (firstCell) {
                    const rect = firstCell.getBoundingClientRect();
                    cellSize = rect.width;
                }
                
                drawBoard();
                rebuildActivePiece();
                drawNext();
                updateScore();
                updateCombo();
                setWorld();
            });
            
            $('title-screen').style.display = 'none';
            $('game').style.display = 'flex';
            $('gameover').classList.remove('show');
            
            // ËêΩ‰∏ã„Çø„Ç§„Éû„Éº
            clearInterval(dropTimer);
            dropTimer = setInterval(() => {
                if (!gameOver && !paused) {
                    move(0, 1);
                }
            }, 500);
            
            // „Éì„Éº„Éà„Éï„Çß„Éº„Ç∫Êõ¥Êñ∞
            requestAnimationFrame(function updateBeat() {
                if (!gameOver) {
                    const world = WORLDS[worldIdx];
                    const interval = 60000 / world.bpm;
                    const elapsed = Date.now() - lastBeat;
                    beatPhase = (elapsed % interval) / interval;
                    beatFill.style.width = (beatPhase * 100) + '%';
                    requestAnimationFrame(updateBeat);
                }
            });
        }

        function endGame() {
            gameOver = true;
            clearInterval(dropTimer);
            clearInterval(beatTimer);
            $('final-score').textContent = score.toLocaleString() + ' pts';
            $('gameover').classList.add('show');
            playTone(131, 0.5, 'sawtooth');
        }

        // ===== „Ç§„Éô„É≥„Éà =====
        $('start-btn').onclick = () => {
            initAudio();
            startGame();
        };
        
        $('restart-btn').onclick = () => {
            startGame();
        };

        // „Ç≥„É≥„Éà„É≠„Éº„É´„Éú„Çø„É≥
        document.querySelectorAll('.ctrl-btn').forEach(btn => {
            const action = btn.dataset.action;
            let lastTrigger = 0;
            const handler = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // ÈÄ£Á∂öÁô∫ÁÅ´Èò≤Ê≠¢Ôºà100ms‰ª•ÂÜÖ„ÅÆÂÜçÁô∫ÁÅ´„ÇíÁÑ°Ë¶ñÔºâ
                const now = Date.now();
                if (now - lastTrigger < 100) return;
                lastTrigger = now;
                
                switch(action) {
                    case 'left': move(-1, 0); break;
                    case 'right': move(1, 0); break;
                    case 'down': move(0, 1); break;
                    case 'rotate': rotatePiece(); break;
                    case 'drop': hardDrop(); break;
                }
            };
            
            // „Çø„ÉÉ„ÉÅ„Éá„Éê„Ç§„Çπ„Åß„ÅØtouchend„ÅÆ„Åø„ÄÅ„Åù„Çå‰ª•Â§ñ„ÅØclick„ÅÆ„Åø
            btn.addEventListener('touchend', handler, { passive: false });
            btn.addEventListener('click', (e) => {
                // „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„ÅåÁô∫ÁÅ´„Åó„ÅüÂ†¥Âêà„ÅØclick„ÇíÁÑ°Ë¶ñ
                if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
                handler(e);
            });
        });

        // „Ç≠„Éº„Éú„Éº„Éâ
        document.addEventListener('keydown', e => {
            switch(e.key) {
                case 'ArrowLeft': move(-1, 0); break;
                case 'ArrowRight': move(1, 0); break;
                case 'ArrowDown': move(0, 1); break;
                case 'ArrowUp': rotatePiece(); break;
                case ' ': e.preventDefault(); hardDrop(); break;
            }
        });

        // ÂàùÊúüÂåñ
        beatPhase = 0;
        lastBeat = Date.now();
    </script>
</body>
</html>
