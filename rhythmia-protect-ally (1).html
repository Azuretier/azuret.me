<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RHYTHMIA - PROTECT ALLY</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; }
        
        html, body { 
            height: 100%; 
            overflow: hidden; 
            touch-action: manipulation;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a12 0%, #1a0a2e 100%);
            transition: background 0.5s;
        }

        /* „ÉØ„Éº„É´„Éâ„ÉÜ„Éº„Éû */
        .w0 { --c1: #FF6B9D; --c2: #C44569; --bg: #1a1025; }
        .w1 { --c1: #4ECDC4; --c2: #1A535C; --bg: #051620; }
        .w2 { --c1: #FFE66D; --c2: #F7B731; --bg: #1a1505; }
        .w3 { --c1: #FF6B6B; --c2: #C0392B; --bg: #1a0a0a; }
        .w4 { --c1: #A29BFE; --c2: #6C5CE7; --bg: #0a0a1a; }

        body { background: var(--bg); }

        #game {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            gap: 10px;
        }

        /* „Éà„ÉÉ„Éó„Éê„Éº */
        #top-bar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0,0,0,0.3);
            border-bottom: 2px solid var(--c1);
            gap: 20px;
        }

        #stage-display {
            color: var(--c1);
            font-size: 1.2rem;
            font-weight: 700;
            text-shadow: 0 0 10px var(--c1);
        }

        #score-display {
            font-size: 1.5rem;
            font-weight: 900;
            color: white;
            text-shadow: 0 0 20px var(--c1);
            flex-grow: 1;
            text-align: center;
            transition: transform 0.1s;
        }
        #score-display.pop { transform: scale(1.15); }

        #combo {
            font-size: 1rem;
            font-weight: 700;
            color: var(--c1);
            opacity: 0;
            transform: scale(0);
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
        }
        #combo.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        #combo.big { transform: translate(-50%, -50%) scale(1.5); color: #FFD700; }

        #ally-health {
            color: #00FF00;
            font-size: 1.2rem;
            font-weight: 700;
            text-shadow: 0 0 10px #00FF00;
            min-width: 100px;
            text-align: right;
        }

        /* „Ç≤„Éº„É† „Ç®„É™„Ç¢ */
        #game-area {
            position: relative;
            display: flex;
            gap: 10px;
            align-items: flex-start;
            flex: 1;
        }

        /* Âë≥ÊñπÊÉÖÂ†±„Éë„Éç„É´ */
        #ally-panel {
            background: rgba(0,100,0,0.2);
            border: 2px solid #00FF00;
            border-radius: 8px;
            padding: 12px;
            width: min(140px, 22vw);
            text-align: center;
        }

        #ally-label {
            color: #00FF00;
            font-size: 0.8rem;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 0 8px #00FF00;
        }

        #ally-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        #ally-health-bar {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #00FF00;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        #ally-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #00FF00, #00DD00);
            transition: width 0.3s;
            box-shadow: 0 0 10px #00FF00;
        }

        #ally-health-text {
            color: #00FF00;
            font-size: 0.8rem;
            font-weight: 700;
        }

        #ally-threat {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0,255,0,0.3);
        }

        #threat-label {
            color: rgba(255,255,255,0.6);
            font-size: 0.7rem;
        }

        #threat-value {
            color: #FFD700;
            font-size: 1rem;
            font-weight: 700;
        }

        /* „Éú„Éº„Éâ */
        #board-wrap {
            position: relative;
            border: 3px solid var(--c1);
            border-radius: 8px;
            background: rgba(0,0,0,0.5);
            box-shadow: 0 0 30px var(--c1), inset 0 0 30px rgba(0,0,0,0.5);
            transition: box-shadow 0.1s, transform 0.1s;
            overflow: hidden;
        }
        #board-wrap.beat { 
            box-shadow: 0 0 50px var(--c1), 0 0 80px var(--c1), inset 0 0 30px rgba(0,0,0,0.5);
            transform: scale(1.02);
        }
        #board-wrap.shake {
            animation: shake 0.2s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        #board {
            display: grid;
            gap: 1px;
        }

        .cell {
            width: clamp(16px, 4vw, 28px);
            height: clamp(16px, 4vw, 28px);
            background: rgba(255,255,255,0.03);
            border-radius: 2px;
            transition: all 0.1s;
        }
        .cell.filled {
            box-shadow: 0 0 10px currentColor, inset 0 0 8px rgba(255,255,255,0.3);
        }
        .cell.ghost {
            opacity: 0.3;
        }
        .cell.clearing {
            animation: clear 0.3s ease-out forwards;
        }
        @keyframes clear {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); background: white; }
            100% { transform: scale(0); opacity: 0; }
        }

        /* NEXT */
        #next-wrap {
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px;
        }
        #next-label {
            color: rgba(255,255,255,0.5);
            font-size: 0.7rem;
            text-align: center;
            margin-bottom: 5px;
        }
        #next {
            display: grid;
            gap: 1px;
        }
        .next-cell {
            width: clamp(12px, 3vw, 20px);
            height: clamp(12px, 3vw, 20px);
            border-radius: 2px;
        }

        /* Êïµ„ÅÆËÑÖÂ®ÅÊÉÖÂ†± */
        #threat-info {
            background: rgba(100,0,0,0.2);
            border: 2px solid rgba(255,100,100,0.5);
            border-radius: 8px;
            padding: 10px;
            width: min(200px, 25vw);
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
        }

        #threat-enemy-name {
            color: #FF6B6B;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #FF6B6B;
        }

        #threat-bar {
            width: 100%;
            height: 16px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        #threat-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF4444, #FF8888);
            transition: width 0.3s;
            box-shadow: 0 0 10px #FF4444;
        }

        #threat-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 0.8rem;
        }

        .threat-item {
            text-align: center;
        }
        .threat-item-label {
            color: rgba(255,255,255,0.5);
            font-size: 0.7rem;
        }
        .threat-item-value {
            color: #FF6B6B;
            font-weight: 700;
        }

        /* „Éì„Éº„Éà„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº */
        #beat-bar {
            width: min(300px, 80vw);
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        #beat-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--c2), var(--c1));
            border-radius: 10px;
            transition: width 0.05s linear;
            box-shadow: 0 0 20px var(--c1);
        }
        #beat-target {
            position: absolute;
            right: 10%;
            top: 0;
            bottom: 0;
            width: 15%;
            background: rgba(255,215,0,0.3);
            border: 2px solid #FFD700;
            border-radius: 8px;
        }

        /* Âà§ÂÆöË°®Á§∫ */
        #judgment {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2rem, 10vw, 5rem);
            font-weight: 900;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }
        #judgment.show {
            animation: judgePop 0.5s ease-out forwards;
        }
        @keyframes judgePop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
            100% { opacity: 0; transform: translate(-50%, -60%) scale(1); }
        }

        /* „Ç≥„É≥„Éà„É≠„Éº„É´ */
        #controls {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            width: min(350px, 90vw);
            margin-top: auto;
        }
        .ctrl-btn {
            aspect-ratio: 1;
            background: linear-gradient(135deg, var(--c1), var(--c2));
            border: none;
            border-radius: 12px;
            color: white;
            font-size: clamp(1.2rem, 4vw, 2rem);
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        .ctrl-btn:active {
            transform: scale(0.9);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* „Çø„Ç§„Éà„É´ÁîªÈù¢ */
        #title-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0a0a12, #1a0a2e);
            z-index: 200;
            gap: 30px;
        }
        #title-screen h1 {
            font-size: clamp(3rem, 12vw, 6rem);
            font-weight: 900;
            color: white;
            text-shadow: 0 0 30px #FF6B9D, 0 0 60px #FF6B9D;
        }
        #title-screen .subtitle {
            color: rgba(0,255,0,0.9);
            font-size: 1.3rem;
            font-weight: 700;
            text-shadow: 0 0 10px #00FF00;
        }
        #title-screen p {
            color: rgba(255,255,255,0.7);
            font-size: 1rem;
            max-width: 300px;
            text-align: center;
        }
        #start-btn {
            padding: 20px 60px;
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(135deg, #FF6B9D, #C44569);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            box-shadow: 0 0 30px #FF6B9D;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px #FF6B9D;
        }

        /* „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº */
        #gameover {
            position: fixed;
            inset: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.95);
            z-index: 200;
            gap: 20px;
            padding: 20px;
        }
        #gameover.show { display: flex; }
        #gameover h2 {
            font-size: 3rem;
            font-weight: 900;
            text-shadow: 0 0 30px var(--c1);
        }
        #gameover h2.victory {
            color: #00FF00;
            text-shadow: 0 0 30px #00FF00;
        }
        #gameover h2.defeat {
            color: #FF6B6B;
            text-shadow: 0 0 30px #FF6B6B;
        }
        
        #final-stats {
            background: rgba(255,107,157,0.1);
            border: 2px solid var(--c1);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            color: white;
        }

        #final-score {
            font-size: 2.5rem;
            font-weight: 900;
            color: #FFD700;
            margin: 10px 0;
            text-shadow: 0 0 20px #FFD700;
        }

        .stat-row {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
            font-size: 1rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            color: rgba(255,255,255,0.6);
            font-size: 0.85rem;
        }

        .stat-value {
            color: var(--c1);
            font-weight: 700;
            font-size: 1.2rem;
        }

        #restart-btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #FF6B9D, #C44569);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #restart-btn:hover {
            transform: scale(1.05);
        }

        /* „Éë„Éº„ÉÜ„Ç£„ÇØ„É´ */
        .particle {
            position: fixed;
            pointer-events: none;
            border-radius: 50%;
            z-index: 150;
        }

        /* „Çπ„ÉÜ„Éº„Ç∏„ÇØ„É™„Ç¢Ë°®Á§∫ */
        #stage-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: 900;
            color: #00FF00;
            text-shadow: 0 0 30px #00FF00;
            opacity: 0;
            pointer-events: none;
            z-index: 150;
        }
        #stage-notification.show {
            animation: stageAnim 1.5s ease-out forwards;
        }
        @keyframes stageAnim {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body class="w0">
    <!-- „Çø„Ç§„Éà„É´ -->
    <div id="title-screen">
        <h1>RHYTHMIA</h1>
        <div class="subtitle">PROTECT ALLY MODE</div>
        <p>„É™„Ç∫„É†„Å´‰πó„Å£„Å¶Âë≥Êñπ„ÇíÂÆà„Çã„ÄÇ<br>Êïµ„ÅÆËÑÖÂ®Å„Åã„Çâ‰ª≤Èñì„ÇíÊïë„ÅÑÂá∫„ÅõÔºÅ</p>
        <button id="start-btn">‚ñ∂ START</button>
    </div>

    <!-- „Ç≤„Éº„É† -->
    <div id="game" style="display:none;">
        <!-- „Éà„ÉÉ„Éó„Éê„Éº -->
        <div id="top-bar">
            <div id="stage-display">STAGE: 1</div>
            <div style="position: relative; flex-grow: 1;">
                <div id="score-display">0</div>
                <div id="combo">10 COMBO!</div>
            </div>
            <div id="ally-health">‚ù§Ô∏è 100%</div>
        </div>

        <!-- „É°„Ç§„É≥„Ç®„É™„Ç¢ -->
        <div id="game-area">
            <!-- Âë≥Êñπ„Éë„Éç„É´ -->
            <div id="ally-panel">
                <div id="ally-label">üé≠ ALLY</div>
                <div id="ally-icon">üòä</div>
                <div id="ally-health-bar"><div id="ally-health-fill" style="width:100%"></div></div>
                <div id="ally-health-text">HP: 100/100</div>
                <div id="ally-threat">
                    <div id="threat-label">ËÑÖÂ®Å„É¨„Éô„É´</div>
                    <div id="threat-value">0</div>
                </div>
            </div>

            <div id="board-wrap">
                <div id="board"></div>
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <div id="next-wrap">
                    <div id="next-label">NEXT</div>
                    <div id="next"></div>
                </div>

                <div id="threat-info">
                    <div id="threat-enemy-name">Êïµ„Å™„Åó</div>
                    <div id="threat-bar"><div id="threat-fill" style="width:0%"></div></div>
                    <div id="threat-stats">
                        <div class="threat-item">
                            <div class="threat-item-label">BPM</div>
                            <div class="threat-item-value" id="bpm-display">100</div>
                        </div>
                        <div class="threat-item">
                            <div class="threat-item-label">ËÑÖÂ®Å</div>
                            <div class="threat-item-value" id="threat-level">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="beat-bar">
            <div id="beat-target"></div>
            <div id="beat-fill" style="width:0%"></div>
        </div>
        
        <div id="controls">
            <button class="ctrl-btn" data-action="rotate">‚Üª</button>
            <button class="ctrl-btn" data-action="left">‚Üê</button>
            <button class="ctrl-btn" data-action="down">‚Üì</button>
            <button class="ctrl-btn" data-action="right">‚Üí</button>
            <button class="ctrl-btn" data-action="drop">‚¨á</button>
        </div>
    </div>

    <!-- Âà§ÂÆö -->
    <div id="judgment"></div>
    <div id="stage-notification"></div>

    <!-- „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº -->
    <div id="gameover">
        <h2 id="gameover-title">GAME OVER</h2>
        <div id="final-stats">
            <div id="result-text">„Ç≤„Éº„É†ÁµÇ‰∫Ü</div>
            <div id="final-score">0</div>
            <div class="stat-row">
                <div class="stat-item">
                    <div class="stat-label">Âà∞ÈÅî„Çπ„ÉÜ„Éº„Ç∏</div>
                    <div class="stat-value" id="final-stage">1</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Ê∂à„Åó„Åü„É©„Ç§„É≥</div>
                    <div class="stat-value" id="final-lines">0</div>
                </div>
            </div>
            <div class="stat-row">
                <div class="stat-item">
                    <div class="stat-label">ÊúÄÂ§ß„Ç≥„É≥„Éú</div>
                    <div class="stat-value" id="final-max-combo">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Á¥ØÁ©ç„ÉÄ„É°„Éº„Ç∏</div>
                    <div class="stat-value" id="final-damage">0</div>
                </div>
            </div>
        </div>
        <button id="restart-btn">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
    </div>

    <script>
        // ===== Ë®≠ÂÆö =====
        const W = 10, H = 18;
        
        const STAGES = [
            { name: '„Çπ„É©„Ç§„É†Áæ§', enemies: ['üü¢ „Çπ„É©„Ç§„É†A', 'üü¢ „Çπ„É©„Ç§„É†B', 'üü¢ „Çπ„É©„Ç§„É†C'], threatBase: 5 },
            { name: '„Ç¥„Éñ„É™„É≥ÈÉ®Èöä', enemies: ['üü§ „Ç¥„Éñ„É™„É≥', 'üü§ „Ç¥„Éñ„É™„É≥Êà¶Â£´'], threatBase: 8 },
            { name: '„Ç™„Éº„ÇØ„ÅÆ‰æµÊîª', enemies: ['üü™ „Ç™„Éº„ÇØ', 'üü™ „Ç™„Éº„ÇØ„É≠„Éº„Éâ'], threatBase: 10 },
            { name: '„Éâ„É©„Ç¥„É≥„ÅÆÁõÆË¶ö„ÇÅ', enemies: ['üî¥ „Éâ„É©„Ç¥„É≥', 'üî¥ „Ç®„É≥„Ç∑„Çß„É≥„Éà„Éâ„É©„Ç¥„É≥'], threatBase: 15 },
            { name: 'È≠îÁéãÂüéÂ•™ÈÇÑ', enemies: ['üëπ È≠îÁéãËªçÂõ£', 'üëπ È≠îÁéã'], threatBase: 20 },
        ];
        
        const SHAPES = [
            [[1,1,1,1]],
            [[1,1],[1,1]],
            [[0,1,0],[1,1,1]],
            [[0,1,1],[1,1,0]],
            [[1,1,0],[0,1,1]],
            [[1,0,0],[1,1,1]],
            [[0,0,1],[1,1,1]]
        ];

        const WORLD_THEMES = [
            { colors: ['#FF6B9D','#FF8FAB','#FFB6C1','#C44569','#E8668B','#D4587D','#B84A6F'], class: 'w0' },
            { colors: ['#4ECDC4','#45B7AA','#3DA69B','#35958C','#2D847D','#26736E','#1A535C'], class: 'w1' },
            { colors: ['#FFE66D','#FFD93D','#F7B731','#ECA700','#D19600','#B68600','#9B7600'], class: 'w2' },
            { colors: ['#FF6B6B','#FF5252','#FF3838','#FF1F1F','#E61717','#CC0F0F','#B30707'], class: 'w3' },
            { colors: ['#A29BFE','#9B8EFD','#9381FC','#8B74FB','#8367FA','#7B5AF9','#6C5CE7'], class: 'w4' }
        ];

        // ===== Áä∂ÊÖã =====
        let board, piece, piecePos, nextPiece, score, combo, maxCombo, level, lines;
        let stage, currentEnemies, threatLevel, allyHP, allyMaxHP, totalDamageDealt;
        let gameOver, paused, victory;
        let beatPhase, lastBeat, audioCtx;
        let dropTimer, beatTimer;
        let baseBpm = 100;

        // ===== DOM =====
        const $ = id => document.getElementById(id);
        const boardEl = $('board');
        const nextEl = $('next');
        const scoreEl = $('score-display');
        const comboEl = $('combo');
        const judgmentEl = $('judgment');
        const beatFill = $('beat-fill');
        const threatFill = $('threat-fill');
        const threatEnemyNameEl = $('threat-enemy-name');
        const stageEl = $('stage-display');
        const allyHealthEl = $('ally-health');
        const allyHealthFillEl = $('ally-health-fill');
        const allyHealthTextEl = $('ally-health-text');
        const threatValueEl = $('threat-value');
        const bpmDisplay = $('bpm-display');
        const threatLevelEl = $('threat-level');
        const stageNotif = $('stage-notification');
        const boardWrap = $('board-wrap');
        const allyIcon = $('ally-icon');

        // ===== „Çµ„Ç¶„É≥„Éâ =====
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playTone(freq, dur = 0.1, type = 'sine') {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + dur);
        }

        function playDrum() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function playLineClear(count) {
            const freqs = [523, 659, 784, 1047];
            freqs.slice(0, count).forEach((f, i) => setTimeout(() => playTone(f, 0.15, 'triangle'), i * 60));
        }

        function playStageUp() {
            playTone(523, 0.2, 'sine');
            setTimeout(() => playTone(659, 0.2, 'sine'), 100);
            setTimeout(() => playTone(784, 0.3, 'sine'), 200);
        }

        function playAllyDamage() {
            playTone(200, 0.3, 'sawtooth');
        }

        // ===== „Éë„Éº„ÉÜ„Ç£„ÇØ„É´ =====
        function spawnParticles(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                const size = Math.random() * 10 + 5;
                const angle = (Math.PI * 2 / count) * i;
                const dist = Math.random() * 80 + 40;
                p.style.cssText = `
                    left: ${x}px; top: ${y}px;
                    width: ${size}px; height: ${size}px;
                    background: ${color};
                    box-shadow: 0 0 10px ${color};
                    transition: all 0.5s ease-out;
                `;
                document.body.appendChild(p);
                requestAnimationFrame(() => {
                    p.style.transform = `translate(${Math.cos(angle) * dist}px, ${Math.sin(angle) * dist}px) scale(0)`;
                    p.style.opacity = '0';
                });
                setTimeout(() => p.remove(), 500);
            }
        }

        // ===== „Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ =====
        function createBoard() {
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${W}, 1fr)`;
            for (let i = 0; i < W * H; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                boardEl.appendChild(cell);
            }
        }

        function randomPiece() {
            const theme = WORLD_THEMES[stage % WORLD_THEMES.length];
            const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
            const color = theme.colors[Math.floor(Math.random() * theme.colors.length)];
            return { shape, color };
        }

        function drawBoard() {
            const cells = boardEl.children;
            const display = board.map(r => [...r]);
            
            if (piece) {
                let gy = piecePos.y;
                while (!collision(piece, piecePos.x, gy + 1)) gy++;
                piece.shape.forEach((row, py) => {
                    row.forEach((val, px) => {
                        if (val) {
                            const by = gy + py, bx = piecePos.x + px;
                            if (by >= 0 && by < H && bx >= 0 && bx < W && !display[by][bx]) {
                                display[by][bx] = { color: piece.color, ghost: true };
                            }
                        }
                    });
                });
                
                piece.shape.forEach((row, py) => {
                    row.forEach((val, px) => {
                        if (val) {
                            const by = piecePos.y + py, bx = piecePos.x + px;
                            if (by >= 0 && by < H && bx >= 0 && bx < W) {
                                display[by][bx] = { color: piece.color, ghost: false };
                            }
                        }
                    });
                });
            }
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const cell = cells[y * W + x];
                    const val = display[y][x];
                    if (val) {
                        cell.className = 'cell filled' + (val.ghost ? ' ghost' : '');
                        cell.style.backgroundColor = val.color;
                        cell.style.color = val.color;
                    } else {
                        cell.className = 'cell';
                        cell.style.backgroundColor = '';
                        cell.style.color = '';
                    }
                }
            }
        }

        function drawNext() {
            if (!nextPiece) return;
            const shape = nextPiece.shape;
            nextEl.innerHTML = '';
            nextEl.style.gridTemplateColumns = `repeat(${shape[0].length}, 1fr)`;
            shape.forEach(row => {
                row.forEach(val => {
                    const cell = document.createElement('div');
                    cell.className = 'next-cell';
                    if (val) {
                        cell.style.backgroundColor = nextPiece.color;
                        cell.style.boxShadow = `0 0 8px ${nextPiece.color}`;
                    }
                    nextEl.appendChild(cell);
                });
            });
        }

        function collision(p, x, y) {
            return p.shape.some((row, py) =>
                row.some((val, px) => {
                    if (!val) return false;
                    const nx = x + px, ny = y + py;
                    return nx < 0 || nx >= W || ny >= H || (ny >= 0 && board[ny][nx]);
                })
            );
        }

        function rotate(p) {
            return {
                ...p,
                shape: p.shape[0].map((_, i) => p.shape.map(row => row[i]).reverse())
            };
        }

        function updateThreat() {
            // ËÑÖÂ®Å„É¨„Éô„É´„ÅåÂ∏∏„Å´Â¢óÂä†
            threatLevel = Math.min(100, threatLevel + 0.5);
            threatFill.style.width = threatLevel + '%';
            threatLevelEl.textContent = Math.floor(threatLevel);

            // ËÑÖÂ®Å„Åå‰∏ÄÂÆöÂÄ§„ÇíË∂Ö„Åà„Åü„ÇâÂë≥Êñπ„Åå„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Çã
            if (threatLevel >= 100) {
                const damage = 20;
                allyHP = Math.max(0, allyHP - damage);
                totalDamageDealt += damage;
                threatLevel = 0;
                threatFill.style.width = '0%';
                threatLevelEl.textContent = '0';

                playAllyDamage();
                boardWrap.classList.add('shake');
                setTimeout(() => boardWrap.classList.remove('shake'), 200);

                updateAllyHealth();

                if (allyHP <= 0) {
                    endGame(false);
                }
            }
        }

        function updateAllyHealth() {
            const healthPercent = (allyHP / allyMaxHP) * 100;
            allyHealthFillEl.style.width = healthPercent + '%';
            allyHealthTextEl.textContent = `HP: ${allyHP}/${allyMaxHP}`;
            allyHealthEl.textContent = `‚ù§Ô∏è ${Math.floor(healthPercent)}%`;

            // ‰ΩìÂäõ„ÅåÊ∏õ„Çã„Å®È°î„ÅåÂ§â„Çè„Çã
            if (healthPercent > 66) {
                allyIcon.textContent = 'üòä';
            } else if (healthPercent > 33) {
                allyIcon.textContent = 'üòü';
            } else {
                allyIcon.textContent = 'üò®';
            }
        }

        function lock() {
            const onBeat = beatPhase > 0.75 || beatPhase < 0.15;
            let mult = 1;
            
            if (onBeat) {
                mult = 2;
                combo++;
                maxCombo = Math.max(maxCombo, combo);
                showJudgment('PERFECT!', '#FFD700');
                playTone(1047, 0.2, 'triangle');
                const rect = boardWrap.getBoundingClientRect();
                spawnParticles(rect.left + rect.width/2, rect.top + rect.height/2, '#FFD700', 12);
                
                // PERFECTÊôÇ„ÅØËÑÖÂ®Å„ÅåÂ§ß„Åç„ÅèÊ∏õÂ∞ë
                threatLevel = Math.max(0, threatLevel - 20);
            } else {
                combo = 0;
                // Â§±ÊïóÊôÇ„ÅØËÑÖÂ®Å„ÅåÂ¢óÂä†
                threatLevel = Math.min(100, threatLevel + 5);
            }
            
            updateCombo();
            
            piece.shape.forEach((row, py) => {
                row.forEach((val, px) => {
                    if (val) {
                        const by = piecePos.y + py, bx = piecePos.x + px;
                        if (by >= 0 && by < H) {
                            board[by][bx] = { color: piece.color };
                        }
                    }
                });
            });
            
            let cleared = 0;
            const newBoard = [];
            const clearingRows = [];
            
            board.forEach((row, y) => {
                if (row.every(c => c !== null)) {
                    cleared++;
                    clearingRows.push(y);
                } else {
                    newBoard.push(row);
                }
            });
            
            if (cleared > 0) {
                const cells = boardEl.children;
                clearingRows.forEach(y => {
                    for (let x = 0; x < W; x++) {
                        cells[y * W + x].classList.add('clearing');
                    }
                });
                
                setTimeout(() => {
                    while (newBoard.length < H) newBoard.unshift(Array(W).fill(null));
                    board = newBoard;
                    
                    const baseScore = [0, 100, 300, 500, 800][cleared];
                    const stageBonus = stage * 50;
                    const pts = (baseScore + stageBonus) * (level + 1) * mult * Math.max(1, combo);
                    score += pts;
                    lines += cleared;
                    
                    // „É©„Ç§„É≥Ê∂àÂéª„ÅßËÑÖÂ®Å„ÅåÊ∏õÂ∞ë
                    threatLevel = Math.max(0, threatLevel - cleared * 10);
                    threatFill.style.width = threatLevel + '%';
                    threatLevelEl.textContent = Math.floor(threatLevel);
                    
                    level = Math.floor(lines / 10);
                    updateScore();
                    playLineClear(cleared);
                    boardWrap.classList.add('shake');
                    setTimeout(() => boardWrap.classList.remove('shake'), 200);
                    
                    drawBoard();
                    
                    // „Çπ„ÉÜ„Éº„Ç∏„ÇØ„É™„Ç¢Âà§ÂÆö
                    if (lines >= stage * 10) {
                        nextStage();
                    }
                }, 300);
            }
            
            piece = nextPiece;
            nextPiece = randomPiece();
            piecePos = { x: Math.floor(W/2) - 1, y: 0 };
            drawNext();
            drawBoard();
            
            if (collision(piece, piecePos.x, piecePos.y)) {
                endGame(false);
            }
        }

        function move(dx, dy) {
            if (gameOver || paused || !piece) return;
            if (!collision(piece, piecePos.x + dx, piecePos.y + dy)) {
                piecePos.x += dx;
                piecePos.y += dy;
                if (dx !== 0) playTone(392, 0.05, 'square');
                drawBoard();
            } else if (dy > 0) {
                lock();
            }
        }

        function rotatePiece() {
            if (gameOver || paused || !piece) return;
            const rotated = rotate(piece);
            if (!collision(rotated, piecePos.x, piecePos.y)) {
                piece = rotated;
                playTone(523, 0.08);
                drawBoard();
            }
        }

        function hardDrop() {
            if (gameOver || paused || !piece) return;
            while (!collision(piece, piecePos.x, piecePos.y + 1)) {
                piecePos.y++;
            }
            playTone(196, 0.1, 'sawtooth');
            drawBoard();
            setTimeout(lock, 30);
        }

        function showJudgment(text, color) {
            judgmentEl.textContent = text;
            judgmentEl.style.color = color;
            judgmentEl.style.textShadow = `0 0 30px ${color}`;
            judgmentEl.className = '';
            void judgmentEl.offsetWidth;
            judgmentEl.classList.add('show');
        }

        function updateScore() {
            scoreEl.textContent = score.toLocaleString();
            scoreEl.classList.add('pop');
            setTimeout(() => scoreEl.classList.remove('pop'), 100);
        }

        function updateCombo() {
            if (combo >= 2) {
                comboEl.textContent = combo + ' COMBO!';
                comboEl.classList.add('show');
                if (combo >= 5) comboEl.classList.add('big');
                else comboEl.classList.remove('big');
            } else {
                comboEl.classList.remove('show', 'big');
            }
        }

        function nextStage() {
            stage++;
            combo = 0;
            lines = 0;
            updateCombo();
            
            if (stage > STAGES.length) {
                // „Ç≤„Éº„É†„ÇØ„É™„Ç¢
                endGame(true);
                return;
            }
            
            showJudgment(`STAGE ${stage}!`, '#00FF00');
            playStageUp();
            
            const stageData = STAGES[stage - 1];
            currentEnemies = stageData.enemies;
            const enemyIdx = Math.floor(Math.random() * currentEnemies.length);
            threatEnemyNameEl.textContent = currentEnemies[enemyIdx];
            threatLevel = 0;
            threatFill.style.width = '0%';
            threatLevelEl.textContent = '0';
            
            baseBpm = 100 + (stage - 1) * 5;
            bpmDisplay.textContent = baseBpm;
            
            stageEl.textContent = `STAGE: ${stage}`;
            
            document.body.className = WORLD_THEMES[(stage - 1) % WORLD_THEMES.length].class;
            
            updateBeatTimer();
            
            stageNotif.textContent = `STAGE ${stage}\n${stageData.name}`;
            stageNotif.classList.remove('show');
            void stageNotif.offsetWidth;
            stageNotif.classList.add('show');
        }

        function updateBeatTimer() {
            clearInterval(beatTimer);
            const interval = 60000 / baseBpm;
            lastBeat = Date.now();
            beatTimer = setInterval(() => {
                lastBeat = Date.now();
                boardWrap.classList.add('beat');
                playDrum();
                setTimeout(() => boardWrap.classList.remove('beat'), 100);
            }, interval);
        }

        function startGame() {
            board = Array(H).fill().map(() => Array(W).fill(null));
            score = 0;
            combo = 0;
            maxCombo = 0;
            level = 0;
            lines = 0;
            stage = 1;
            baseBpm = 100;
            gameOver = false;
            paused = false;
            victory = false;
            threatLevel = 0;
            allyMaxHP = 100;
            allyHP = allyMaxHP;
            totalDamageDealt = 0;
            
            piece = randomPiece();
            nextPiece = randomPiece();
            piecePos = { x: Math.floor(W/2) - 1, y: 0 };
            
            const stageData = STAGES[0];
            currentEnemies = stageData.enemies;
            const enemyIdx = Math.floor(Math.random() * currentEnemies.length);
            threatEnemyNameEl.textContent = currentEnemies[enemyIdx];
            bpmDisplay.textContent = baseBpm;
            
            createBoard();
            drawBoard();
            drawNext();
            updateScore();
            updateCombo();
            updateAllyHealth();
            
            $('title-screen').style.display = 'none';
            $('game').style.display = 'flex';
            $('gameover').classList.remove('show');
            
            document.body.className = WORLD_THEMES[0].class;
            stageEl.textContent = 'STAGE: 1';
            
            clearInterval(dropTimer);
            dropTimer = setInterval(() => {
                if (!gameOver && !paused) {
                    move(0, 1);
                    updateThreat();
                }
            }, 500);
            
            updateBeatTimer();
            
            requestAnimationFrame(function updateBeat() {
                if (!gameOver) {
                    const interval = 60000 / baseBpm;
                    const elapsed = Date.now() - lastBeat;
                    beatPhase = (elapsed % interval) / interval;
                    beatFill.style.width = (beatPhase * 100) + '%';
                    requestAnimationFrame(updateBeat);
                }
            });
        }

        function endGame(isVictory) {
            gameOver = true;
            victory = isVictory;
            clearInterval(dropTimer);
            clearInterval(beatTimer);
            
            const finalScore = Math.floor(score);
            $('final-score').textContent = finalScore.toLocaleString();
            $('final-stage').textContent = stage;
            $('final-lines').textContent = lines;
            $('final-max-combo').textContent = maxCombo;
            $('final-damage').textContent = totalDamageDealt;
            
            const gameoverTitle = $('gameover-title');
            const resultText = $('result-text');
            
            if (isVictory) {
                gameoverTitle.textContent = 'VICTORY!';
                gameoverTitle.className = 'victory';
                resultText.textContent = '‚ú® Âë≥Êñπ„ÇíÊïë„ÅÑÂá∫„Åó„ÅüÔºÅ ‚ú®';
                playTone(784, 0.3, 'sine');
                setTimeout(() => playTone(880, 0.3, 'sine'), 150);
                setTimeout(() => playTone(1047, 0.5, 'sine'), 300);
            } else {
                gameoverTitle.textContent = 'GAME OVER';
                gameoverTitle.className = 'defeat';
                resultText.textContent = 'Âë≥Êñπ„ÇíÂÆà„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü...';
                playTone(131, 0.5, 'sawtooth');
            }
            
            $('gameover').classList.add('show');
        }

        // ===== „Ç§„Éô„É≥„Éà =====
        $('start-btn').onclick = () => {
            initAudio();
            startGame();
        };
        
        $('restart-btn').onclick = () => {
            startGame();
        };

        document.querySelectorAll('.ctrl-btn').forEach(btn => {
            const action = btn.dataset.action;
            const handler = () => {
                switch(action) {
                    case 'left': move(-1, 0); break;
                    case 'right': move(1, 0); break;
                    case 'down': move(0, 1); break;
                    case 'rotate': rotatePiece(); break;
                    case 'drop': hardDrop(); break;
                }
            };
            btn.addEventListener('click', handler);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handler();
            });
        });

        document.addEventListener('keydown', e => {
            switch(e.key) {
                case 'ArrowLeft': move(-1, 0); break;
                case 'ArrowRight': move(1, 0); break;
                case 'ArrowDown': move(0, 1); break;
                case 'ArrowUp': rotatePiece(); break;
                case ' ': e.preventDefault(); hardDrop(); break;
            }
        });

        // ===== ÂàùÊúüÂåñ =====
        beatPhase = 0;
        lastBeat = Date.now();
    </script>
</body>
</html>
